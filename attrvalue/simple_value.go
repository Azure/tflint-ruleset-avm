package attrvalue

import (
	"fmt"
	"reflect"
	"slices"

	"github.com/terraform-linters/tflint-plugin-sdk/hclext"
	"github.com/terraform-linters/tflint-plugin-sdk/tflint"
)

// SimpleRule checks whether a string attribute value is one of the expected values.
// It can be used to check string, number, and bool attributes.
type SimpleRule[T any] struct {
	tflint.DefaultRule // Embed the default rule to reuse its implementation

	resourceType   string // e.g. "azurerm_storage_account"
	attributeName  string // e.g. "account_replication_type"
	expectedValues []T    // e.g. []string{"ZRS"}
}

var _ tflint.Rule = (*SimpleRule[any])(nil)

// NewSimpleRule returns a new rule with the given resource type, attribute name, and expected values.
func NewSimpleRule[T any](resourceType string, attributeName string, expectedValues []T) *SimpleRule[T] {
	return &SimpleRule[T]{
		resourceType:   resourceType,
		attributeName:  attributeName,
		expectedValues: expectedValues,
	}
}

func (r *SimpleRule[T]) Name() string {
	return fmt.Sprintf("%s.%s must be: %+v", r.resourceType, r.attributeName, r.expectedValues)
}

func (r *SimpleRule[T]) Enabled() bool {
	return true
}

func (r *SimpleRule[T]) Severity() tflint.Severity {
	return tflint.ERROR
}

func (r *SimpleRule[T]) Check(runner tflint.Runner) error {
	resources, err := runner.GetResourceContent(r.resourceType, &hclext.BodySchema{
		Attributes: []hclext.AttributeSchema{
			{Name: r.attributeName},
		},
	}, nil)
	if err != nil {
		return err
	}

	for _, resource := range resources.Blocks {
		attribute, exists := resource.Body.Attributes[r.attributeName]
		if !exists {
			continue
		}
		var dt T
		val := toPtr(dt)
		ctyType, err := toCtyType(dt)
		if err != nil {
			return err
		}
		if err = runner.EvaluateExpr(attribute.Expr, val, &tflint.EvaluateExprOption{
			WantType: &ctyType,
		}); err != nil {
			if slices.Contains([]string{
				"null value found",           // generated by tflint.
				"null value is not allowed"}, // generated by the test runner.
				err.Error()) {
				continue
			}
		}
		for _, expected := range r.expectedValues {
			exp := toPtr(expected)
			if reflect.DeepEqual(val, exp) {
				return nil
			}
		}
		v := reflect.Indirect(reflect.ValueOf(val))
		return runner.EmitIssue(
			r,
			fmt.Sprintf("%v is an invalid attribute value of `%s` - expecting (one of) %v", v, r.attributeName, r.expectedValues),
			attribute.Range,
		)
	}
	return nil
}
